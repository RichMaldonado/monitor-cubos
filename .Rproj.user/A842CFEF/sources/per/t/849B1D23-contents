# autom_cubos_gv_sector.py

import os
import json
import logging
from datetime import datetime
from playwright.sync_api import sync_playwright, Page, Error as PlaywrightError

# ==============================================================================
# 1. CONFIGURACIÓN CENTRALIZADA
# ==============================================================================

# --- Configuración Global ---
START_URL = "https://commercial.natura.com/"

DOWNLOAD_DIR = "/shared_data"

TIMESTAMP_JSON_PATH = os.path.join(DOWNLOAD_DIR, "update_timestamp.json") 

# --- Credenciales (RECOMENDACIÓN: Mover a variables de entorno) ---
USERNAME = r"natura.ntco.natura\339302"
PASSWORD = "Natura$2025" # ¡Recuerda que esto es un riesgo de seguridad!

# --- MODIFICADO: Configuración de logging para guardar en la carpeta de WSL ---
LOG_FILE_PATH = os.path.join(DOWNLOAD_DIR, "autom_cubos.log")
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - [AutomCubos] - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE_PATH), # Guarda el log en la carpeta de datos de Shiny
        logging.StreamHandler()             # También imprime en la consola
    ]
)

# ==============================================================================
# 2. FUNCIONES AUXILIARES
# ==============================================================================

CALENDAR_DATA = [
    {"ciclo_nombre": "Ciclo 15 2025", "inicio": "26/9/2025 00:00:00", "fin": "3/11/2025 23:59:59"},
    {"ciclo_nombre": "Ciclo 16 2025", "inicio": "17/10/2025 00:00:00", "fin": "24/11/2025 23:59:59"},
    {"ciclo_nombre": "Ciclo 17 2025", "inicio": "7/11/2025 00:00:00", "fin": "15/12/2025 23:59:59"},
    {"ciclo_nombre": "Ciclo 18 2025", "inicio": "28/11/2025 00:00:00", "fin": "5/1/2026 23:59:59"}
    ]

def get_active_cycles(calendar):
    today = datetime.now()
    active_cycle_ids = []
    for cycle in calendar:
        start_date = datetime.strptime(cycle["inicio"], "%d/%m/%Y %H:%M:%S")
        end_date = datetime.strptime(cycle["fin"], "%d/%m/%Y %H:%M:%S")
        if start_date <= today <= end_date:
            parts = cycle["ciclo_nombre"].split()
            cycle_number = parts[1]
            year = parts[2]
            cycle_id = f"{year}{cycle_number.zfill(2)}"
            active_cycle_ids.append(cycle_id)
    return sorted(active_cycle_ids)
        
def update_status_json(file_path: str, status: str, message: str, last_successful_timestamp: str):
    try:
        now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if status == "SUCCESS":
            last_successful_timestamp = now_str
            
        data = {
            "status": status,
            "last_run_timestamp": now_str,
            "last_successful_update": last_successful_timestamp,
            "message": message
        }
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4)
        logging.info(f"Archivo de estado actualizado en '{file_path}' con estado: {status}")
    except Exception as e:
        logging.error(f"CRÍTICO: No se pudo escribir en el archivo de estado JSON: {e}")

def login_to_portal(context) -> Page | None:
    page = context.new_page()
    try:
        logging.info(f"Navegando a la página de inicio: {START_URL}")
        page.goto(START_URL, timeout=90000)
        page.wait_for_url("https://commercial.natura.com/**", timeout=90000)
        page.wait_for_load_state("domcontentloaded", timeout=60000)
        logging.info(f"¡Inicio de sesión exitoso! URL final: {page.url}")
        return page
    except PlaywrightError as e:
        logging.error(f"Ocurrió un error de Playwright durante el login: {e}")
        return None
    except Exception as e:
        logging.error(f"Ocurrió un error inesperado durante el login: {e}")
        return None

def request_report(page: Page, report_level: str, cycle: str) -> bool:
    try:
        logging.info(f"--- Iniciando solicitud para Nivel: '{report_level}', Ciclo: {cycle} ---")
        page.locator('[data-id="reports-searchBusinessModel-search"]').click()
        page.get_by_text("Venta Directa", exact=True).click()
        page.locator('[data-id="reports-searchStructureLevelId-search"]').click()
        page.get_by_text(report_level, exact=True).click()
        page.locator('[data-id="report-searchStartCycle-search"] input').fill(cycle)
        page.locator('[data-id="report-searchEndCycle-search"] input').fill(cycle)
        page.locator('[data-id="report-exportRepost-export"]').click()
        success_notification = page.locator('text="Operación realizada con éxito"')
        success_notification.wait_for(state="visible", timeout=30000)
        logging.info("Confirmación de éxito recibida.")
        success_notification.wait_for(state="hidden", timeout=10000)
        logging.info(f"¡Solicitud para '{report_level}' en ciclo {cycle} realizada con éxito!")
        return True
    except PlaywrightError as e:
        logging.error(f"ERROR durante la solicitud del reporte '{report_level}' para el ciclo {cycle}: {e}")
        return False
    finally:
        logging.info("Limpiando el formulario para la siguiente acción.")
        page.locator('[data-id="report-clearSearch-clear"]').click()
        page.wait_for_timeout(1500)

def download_latest_reports(page: Page, reports_queue: list):
    num_reports_to_download = len(reports_queue)
    logging.info(f"\n--- Iniciando fase de descarga para los {num_reports_to_download} reportes solicitados ---")
    
    update_button = page.get_by_role("button", name="Actualizar Registros")
    downloaded_count = 0
    max_retries = 10
    retry_delay_seconds = 30

    for attempt in range(max_retries):
        if downloaded_count >= num_reports_to_download:
            logging.info("Todos los reportes deseados han sido descargados.")
            break

        logging.info(f"Intento {attempt + 1}/{max_retries}: Actualizando y buscando reportes listos...")
        try:
            update_button.click()
            page.wait_for_load_state("networkidle", timeout=25000)
        except Exception as e:
            logging.warning(f"No se pudo hacer clic en 'Actualizar': {e}")
            page.wait_for_timeout(5000)

        for report_info in filter(lambda r: not r.get("downloaded", False), reports_queue):
            logging.info(f"Buscando reporte para: {report_info['filename']}")
            rows = page.locator("tbody > tr").all()
            
            for row in rows:
                try:
                    ciclo_en_tabla = row.locator('td:nth-child(3)').inner_text(timeout=5000).strip()
                    nivel_en_tabla = row.locator('td:nth-child(4)').inner_text(timeout=5000).strip()
                    status_en_tabla = row.locator('td:nth-child(6)').inner_text(timeout=5000).strip()

                    if (ciclo_en_tabla == report_info['cycle'] and 
                        nivel_en_tabla == report_info['level_code'] and
                        "Disponible para Descarga" in status_en_tabla):
                        
                        logging.info(f"¡Coincidencia encontrada para {report_info['filename']}! Estado: {status_en_tabla}. Descargando...")
                        
                        download_button = row.locator("button[data-id^='request-report-']")
                        
                        if download_button.count() > 0:
                            save_path = os.path.join(DOWNLOAD_DIR, report_info['filename'])
                            with page.expect_download(timeout=90000) as download_info:
                                download_button.click(timeout=15000)
                            
                            download = download_info.value
                            # Asegurarse de que el directorio existe antes de guardar
                            os.makedirs(DOWNLOAD_DIR, exist_ok=True) 
                            download.save_as(save_path)
                            
                            logging.info(f"-> ÉXITO: Reporte guardado como: {save_path}")
                            report_info["downloaded"] = True
                            downloaded_count += 1
                            break 
                        else:
                            logging.warning(f"Se encontró la fila para {report_info['filename']} pero no el botón de descarga.")
                except Exception as e:
                    logging.debug(f"Error menor procesando una fila, se reintentará: {e}")
        
        if downloaded_count < num_reports_to_download and attempt < max_retries - 1:
            logging.info(f"Descargados {downloaded_count}/{num_reports_to_download}. Esperando {retry_delay_seconds} segundos...")
            page.wait_for_timeout(retry_delay_seconds * 1000)

    if downloaded_count == num_reports_to_download:
        logging.info("Todas las descargas completadas.")
        return True 
    else:
        logging.warning(f"Proceso finalizado, pero solo se pudieron descargar {downloaded_count} de {num_reports_to_download} reportes.")
        return False

# ==============================================================================
# 3. FUNCIÓN PRINCIPAL
# ==============================================================================
def main():
    logging.info("--- INICIANDO SCRIPT CONSOLIDADO DE SOLICITUD Y DESCARGA ---")
    
    last_successful_update = "Nunca"
    try:
        if os.path.exists(TIMESTAMP_JSON_PATH):
            with open(TIMESTAMP_JSON_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f)
                last_successful_update = data.get("last_successful_update", "Desconocido")
    except Exception as e:
        logging.warning(f"No se pudo leer el archivo de estado anterior. Se asumirá 'Nunca'. Error: {e}")

    # Asegurarse de que el directorio exista al inicio
    try:
        os.makedirs(DOWNLOAD_DIR, exist_ok=True)
        logging.info(f"Directorio de descargas asegurado en: '{DOWNLOAD_DIR}'")
    except Exception as e:
        message = f"ERROR CRÍTICO: No se puede crear o acceder al directorio de descargas: {DOWNLOAD_DIR}. Error: {e}"
        logging.error(message)
        update_status_json(TIMESTAMP_JSON_PATH, "FAILURE", message, last_successful_update)
        return

    active_cycles = get_active_cycles(CALENDAR_DATA)
    # active_cycles = ["202517"] # PRUEBAS
    if not active_cycles:
        message = "No se encontraron ciclos activos para la fecha de hoy. Terminando."
        logging.warning(message)
        update_status_json(TIMESTAMP_JSON_PATH, "FAILURE", message, last_successful_update)
        return

    logging.info(f"Ciclos activos detectados: {', '.join(active_cycles)}.")

    reports_to_process = []
    for cycle in active_cycles:
        reports_to_process.append({"level_name": "GV", "level_code": "2", "cycle": cycle, "filename": f"CUBOgv_{cycle}.xlsx"})
        reports_to_process.append({"level_name": "Sector", "level_code": "3", "cycle": cycle, "filename": f"CUBOsector_{cycle}.xlsx"})

    process_fully_successful = False
    final_message = ""

    try:
        with sync_playwright() as p:
            browser = None
            context = None
            try:
                browser = p.chromium.launch(headless=True)
                context = browser.new_context(
                    http_credentials={"username": USERNAME, "password": PASSWORD},
                    accept_downloads=True
                )
                
                app_page = login_to_portal(context)
                if not app_page:
                    raise Exception("El inicio de sesión en el portal falló. El script no puede continuar.")

                logging.info("\n--- FASE 1: Solicitando Reportes ---")
                app_page.locator('//*[@id="app"]/div/div/main/div/div[1]/div[3]/div/div/div[1]').click(timeout=30000)
                app_page.locator('//*[@id="app"]/div/div/main/div/div[2]/div[3]/div/ul/div[7]').click(timeout=30000)
                app_page.locator('//*[@id="app"]/div/div/main/div/div[3]/div[3]/div/ul/div[10]').click(timeout=30000)
                app_page.locator('//*[@id="app"]/div/div/main/div/div/div[3]').click(timeout=30000)
                app_page.wait_for_selector('[data-id="reports-searchBusinessModel-search"]', timeout=30000)
                logging.info("Formulario de reportes cargado.")

                all_requests_successful = True
                for report in reports_to_process:
                    success = request_report(app_page, report["level_name"], report["cycle"])
                    if not success:
                        all_requests_successful = False
                
                if not all_requests_successful:
                    raise Exception("Una o más solicitudes de reporte fallaron. No se procederá con la descarga.")

                logging.info("\n--- FASE 2: Descargando Reportes ---")
                app_page.wait_for_selector("h5:has-text('Informes Solicitados')", timeout=30000)
                
                if download_latest_reports(app_page, reports_to_process):
                    process_fully_successful = True
                    final_message = f"Se descargaron exitosamente los {len(reports_to_process)} reportes solicitados."
                else:
                    final_message = "El script finalizó pero no todos los reportes pudieron ser descargados."
                    process_fully_successful = False
            
            finally:
                logging.info("Cerrando el navegador y el contexto...")
                if context:
                    context.close()
                if browser:
                    browser.close()
                logging.info("Navegador cerrado.")
                
    except Exception as e:
        error_message = f"Ocurrió un error en el flujo principal: {e}"
        logging.error(error_message, exc_info=True)
        final_message = error_message
        process_fully_successful = False

    finally:
        # 4. CIERRE Y ACTUALIZACIÓN DE ESTADO FINAL
        logging.info("\n--- FASE 3: Finalizando y Actualizando Estado ---")
        
        if process_fully_successful:
            logging.info(f"PROCESO EXITOSO. {final_message}")
            update_status_json(TIMESTAMP_JSON_PATH, "SUCCESS", final_message, last_successful_update)
        else:
            if not final_message:
                final_message = "La automatización falló por una razón desconocida. Revisa el log."
            logging.error(f"PROCESO FALLIDO. {final_message}")
            update_status_json(TIMESTAMP_JSON_PATH, "FAILURE", final_message, last_successful_update)


# ==============================================================================
# 4. PUNTO DE ENTRADA
# ==============================================================================
if __name__ == "__main__":
    main()